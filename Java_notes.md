### 1.Java基本程序设计结构

#### 1.1 数据类型

> 必须为每个变量声明一种类型
>
> 注：Java有一个给能够表示任意进度的算术包，通常称为“大数值”（big number）。虽然被称为大数值，但它并不是一种新的Java类型，而是一个Java对象。

##### 1.1.1 整型

整型用于表示没有小数部分的数值，它允许是负数。

| 类型  | 存储需求 | 取值范围                    |
| ----- | -------- | --------------------------- |
| int   | 4字节    | -2147483848~214...          |
| short | 2字节    | -32768~32767                |
| long  | 8字节    | -9223372036854775808~922... |
| byte  | 1字节    | -128~127                    |

> byte和short类型主要用于特定的应用场合，例如底层文件处理或者需要控制占有储存空间量的大数组。

##### 1.1.2 浮点类型

| 类型   | 存储需求 | 取值范围                     |
| ------ | -------- | ---------------------------- |
| float  | 4字节    | 大约±3.4+38F（有效位6-7位）  |
| double | 8字节    | 大约±1.79...（有效位为15位） |

* double表示这种类型的数值进度是float类型的两倍；

* 一般采用double类型，float类型精度难以满足需求；

* 需要使用单精度的库或者需要存储大量的数据，适合用float类型。

* float类型的数字有一个后缀F或f（例如，3.14F）。没有后缀F的浮点型（如3.14）默认为double类型。

> 所有的浮点数值计算都遵循IEEE754规范。具体来说，喜爱按用于表示移出和出错秦广的三个特殊的浮点数值：
>
> * 正无穷大
> * 负无穷大
> * NaN（不是一个数字）
>
> 例如，一个正整数除以0的结果为正无穷大。计算0/0或者复数的平方根结果为NaN。

##### 1.1.3 char类型

char类型的字面量值要用单引号括起来。

**特殊字符转义序列：**

| 转义序列 | 名称   | Unicode值 |
| -------- | ------ | --------- |
| \b       | 退格   | \u0008    |
| \t       | 制表   | \u0009    |
| \n       | 换行   | \u000a    |
| \r       | 回车   | \u000d    |
| \‘’      | 双引号 | \u0022    |
| \\*      | 单引号 | \u0027    |
| \\\      | 反斜杠 | \u005c    |

##### 1.1.4 Unicode和char类型

##### 1.1.5 boolean类型

boolen（布尔）类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。

#### 1.2 变量

每个变量都有一个类型（type），在声明变量时，变量的类型位于变量名之前。

##### 1.2.1 变量初始化

声明一个变量之后，必须用复制语句对变量进行显示初始化，千万不要使用未初始化的变量。

##### 1.2.2 常量

在Java中，利用关键字final指示常量。

**关键字final表示这个常量只能被赋值一次，一旦被赋值后，就不能够再更改了。**习惯上，常量名使用全大写。

当某个常量需要在一个类中多个方法中使用，通常将这类常量成为类常量，使用关键字static final设置一个类常量。例：

```java
public class Constants{
    public static final double TEST = 2.54;
    public static void main(String[] args){
        double test1 = 8.5;
        double test2 = 11;
        System.out.println("输出："+ test1*TEST+"和"+test2*TEST);
    }
}
```

类常量的定义位于main方法的外部，因此，在同一个类的其他方法中也可以使用这个常量。而且一个常量被声明为public，那么其他类的方法也可以使用这个常量。

#### 1.3 运算符

##### 1.3.1 数字函数与常量

在

##### 1.3.2 数值类型之间的转换

当使用两个不同数值类型进行二元操作时，先将两个操作数转化为同一类型，然后再进行计算。 

* 如果两个操作数中有一个是double类型，另一个操作数就会转换为double类型。
* 否则，如果其中一个操作数是float类型，另一个操作数将会转换为float类型。
* 否则，如果其中一个操作数是long类型，另一个操作数将会转换为long类型。
* 否则，两个操作数都将被转换为int类型。

> 无信息丢失转换：
>
> byte→short→int→long;
>
> char→int、int→double、float→double；
>
> 可能有精度损失转换：
>
> int→float、long→float、long→double；

##### 1.3.3 强制类型转换

强制类型转换语法格式：

```java
double x = 9.997;
int nx = (int)x;
//变量nx的值为9，强制类型转换通过阶段小数部分浮点值转换为整型。
```

如果相对浮点数进行舍入运算，以便得到最接近的整数（在很多情况下，这种操作更有用），那就使用Math.round方法：

```java
double x = 9.997；
int nx = (int)Math.round(x);
//当调用round的时候，仍然需要使用强制类型转换（int）。其原因是round方法返回的结果为long类型，由于存在信息丢失的可能性，所以只有使用显式的强制类型转换才能够将long类型转换成int类型。
```

> **注：**如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如：（byte）300的实际值为44。

##### 1.3.4 结合赋值和运算符

可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如：

x += 4；

等价于：

x = x + 4；

（一般，要把运算符放在=号左边，如*=或%=。）

> 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换。例如，如果x是一个强制int，则以下语句：
>
> x += 3.5；
>
> 是合法的，将把x设置为(int)(x+3.5)。

##### 1.3.5 自增与自减运算符

后缀或前缀形式都会使变量值加1或减1：

在表达式中，前缀形式会先完成加1，而后缀形式会使用变量原来的值。

```java
int m = 7;
int n = 7;
int a = 2 * ++m;//a=16
int b = 2 * n++;//b=14
```

##### 1.3.6 位运算符

处理整数类型时，可以直接对组成整型数值的各个位完成操作，这意味着可以使用掩码技术得到整数中各个位，位运算包括：

&("and")	|("or")	^("xor")	~("not")

这些运算符按位模式处理。例如，如果n是一个整数变量，而且用二进制表示的n从右边数第4位为1，则：

int fourthBitFromRight = （n & 0b1000）/ 0b1000；

会返回1，否则返回0，利用&并结合使用适当的2的幂，可以把其他位掩掉，而只保留其中某一位。

**>>**和**<<**运算符将位模式左移或者右移。需要建立位模式来完成位掩码时，这两个运算符会很方便：

int fourthBitFromRight = (n &(1 << 3) >> 3);

最后，>>>运算符会用0填充高位，这与>>不同，它会用符号位填充高位，不存在<<<运算符。

##### 1.3.7 括号与运算符级别

如果不适用圆括号，就按照给出的运算符优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算。例如：由于&&的优先级比||优先级高，所以表达式

a&&b||c

等价于

(a&&b)||c

又因为+=是右结合运算符，所以表达式

a += b += c

等价于

a += (b +=c)

| 运算符                                                | 结合性   |
| ----------------------------------------------------- | -------- |
| [].()(方法调用)                                       | 从左向右 |
| ! ~ ++ -- +(一元运算) - (一元运算)()(强制类型转换)new | 从右向左 |
| */%                                                   | 从左向右 |
| +-                                                    | 从左向右 |
| <<  >>  >>>                                           | 从左向右 |
| <  <=  > >=  instanceof                               | 从左向右 |
| ==  !=                                                | 从左向右 |
| &                                                     | 从左向右 |
| ^                                                     | 从左向右 |
| \|                                                    | 从左向右 |
| &&                                                    | 从左向右 |
| \|\|                                                  | 从左向右 |
| ?:                                                    | 从右向左 |
| =  +=  -=  *=  /=  %=  \|=  ^=  <<=  >>=  >>>=        | 从右向左 |

#### 1.4 字符串

##### 1.4.1 子串

String类的substring方法可以从一个较大的字符串提取出一个子串。例如：

```java
String greeting = "Hello";
String s = greeting.substring(1,3);
//创建了一个由字符“Hel”组成的字符串
```

substring方法的第二个参数是不想复制的第一个位置，这里需要复制位置为0、1和2（从0到2，包括0和2）的字符，再substring中从0开始计数，直到3为止，但不包含3。

##### 1.4.2 不可变字符串

```java
String greeting = "Hello";
greeting = greeting.substring(0,3)+"P!";//greeting的值为Help！
//String类没有提供用于修改的字符串，所以需要先提取需要的字符，再拼接上替换的字符串。
```

由于不能修改Java字符串中的字符，所以在Java文档中将String类对象成为不可变字符串

















